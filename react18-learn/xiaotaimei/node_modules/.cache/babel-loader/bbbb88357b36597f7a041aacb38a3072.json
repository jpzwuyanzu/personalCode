{"ast":null,"code":"import React, { forwardRef, useEffect, useImperativeHandle, useMemo, useRef, useState } from 'react';\nimport { withNativeProps } from '../../utils/native-props';\nimport { mergeProps } from '../../utils/with-default-props';\nimport classNames from 'classnames';\nimport { SwiperItem } from './swiper-item';\nimport { devWarning } from '../../utils/dev-log';\nimport { useSpring, animated } from '@react-spring/web';\nimport { useDrag } from '@use-gesture/react';\nimport PageIndicator from '../page-indicator';\nimport { staged } from 'staged-components';\nimport { useRefState } from '../../utils/use-ref-state';\nimport { bound } from '../../utils/bound';\nimport { useIsomorphicLayoutEffect, useUpdateEffect } from 'ahooks';\nconst classPrefix = `adm-swiper`;\nconst defaultProps = {\n  defaultIndex: 0,\n  allowTouchMove: true,\n  autoplay: false,\n  autoplayInterval: 3000,\n  loop: false,\n  direction: 'horizontal',\n  slideSize: 100,\n  trackOffset: 0,\n  stuckAtBoundary: true,\n  rubberband: true\n};\nlet currentUid;\nexport const Swiper = forwardRef(staged((p, ref) => {\n  const props = mergeProps(defaultProps, p);\n  const [uid] = useState({});\n  const isVertical = props.direction === 'vertical';\n  const slideRatio = props.slideSize / 100;\n  const offsetRatio = props.trackOffset / 100;\n  const {\n    validChildren,\n    count\n  } = useMemo(() => {\n    let count = 0;\n    const validChildren = React.Children.map(props.children, child => {\n      if (!React.isValidElement(child)) return null;\n      if (child.type !== SwiperItem) {\n        devWarning('Swiper', 'The children of `Swiper` must be `Swiper.Item` components.');\n        return null;\n      }\n      count++;\n      return child;\n    });\n    return {\n      validChildren,\n      count\n    };\n  }, [props.children]);\n  if (count === 0 || !validChildren) {\n    devWarning('Swiper', '`Swiper` needs at least one child.');\n    return null;\n  }\n  return () => {\n    let loop = props.loop;\n    if (slideRatio * (count - 1) < 1) {\n      loop = false;\n    }\n    const trackRef = useRef(null);\n    function getSlidePixels() {\n      const track = trackRef.current;\n      if (!track) return 0;\n      const trackPixels = isVertical ? track.offsetHeight : track.offsetWidth;\n      return trackPixels * props.slideSize / 100;\n    }\n    const [current, setCurrent] = useState(props.defaultIndex);\n    useUpdateEffect(() => {\n      var _a;\n      (_a = props.onIndexChange) === null || _a === void 0 ? void 0 : _a.call(props, current);\n    }, [current]);\n    const [dragging, setDragging, draggingRef] = useRefState(false);\n    function boundIndex(current) {\n      let min = 0;\n      let max = count - 1;\n      if (props.stuckAtBoundary) {\n        min += offsetRatio / slideRatio;\n        max -= (1 - slideRatio - offsetRatio) / slideRatio;\n      }\n      return bound(current, min, max);\n    }\n    const [{\n      position\n    }, api] = useSpring(() => ({\n      position: boundIndex(current) * 100,\n      config: {\n        tension: 200,\n        friction: 30\n      },\n      onRest: () => {\n        if (draggingRef.current) return;\n        if (!loop) return;\n        const rawX = position.get();\n        const totalWidth = 100 * count;\n        const standardPosition = modulus(rawX, totalWidth);\n        if (standardPosition === rawX) return;\n        api.start({\n          position: standardPosition,\n          immediate: true\n        });\n      }\n    }), [count]);\n    const dragCancelRef = useRef(null);\n    function forceCancelDrag() {\n      var _a;\n      (_a = dragCancelRef.current) === null || _a === void 0 ? void 0 : _a.call(dragCancelRef);\n      draggingRef.current = false;\n    }\n    const bind = useDrag(state => {\n      dragCancelRef.current = state.cancel;\n      if (!state.intentional) return;\n      if (state.first && !currentUid) {\n        currentUid = uid;\n      }\n      if (currentUid !== uid) return;\n      currentUid = state.last ? undefined : uid;\n      const slidePixels = getSlidePixels();\n      if (!slidePixels) return;\n      const paramIndex = isVertical ? 1 : 0;\n      const offset = state.offset[paramIndex];\n      const direction = state.direction[paramIndex];\n      const velocity = state.velocity[paramIndex];\n      setDragging(true);\n      if (!state.last) {\n        api.start({\n          position: offset * 100 / slidePixels,\n          immediate: true\n        });\n      } else {\n        const minIndex = Math.floor(offset / slidePixels);\n        const maxIndex = minIndex + 1;\n        const index = Math.round((offset + velocity * 2000 * direction) / slidePixels);\n        swipeTo(bound(index, minIndex, maxIndex));\n        window.setTimeout(() => {\n          setDragging(false);\n        });\n      }\n    }, {\n      transform: _ref => {\n        let [x, y] = _ref;\n        return [-x, -y];\n      },\n      from: () => {\n        const slidePixels = getSlidePixels();\n        return [position.get() / 100 * slidePixels, position.get() / 100 * slidePixels];\n      },\n      triggerAllEvents: true,\n      bounds: () => {\n        if (loop) return {};\n        const slidePixels = getSlidePixels();\n        const lowerBound = boundIndex(0) * slidePixels;\n        const upperBound = boundIndex(count - 1) * slidePixels;\n        return isVertical ? {\n          top: lowerBound,\n          bottom: upperBound\n        } : {\n          left: lowerBound,\n          right: upperBound\n        };\n      },\n      rubberband: props.rubberband,\n      axis: isVertical ? 'y' : 'x',\n      preventScroll: !isVertical,\n      pointer: {\n        touch: true\n      }\n    });\n    function swipeTo(index) {\n      let immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      const roundedIndex = Math.round(index);\n      const targetIndex = loop ? modulus(roundedIndex, count) : bound(roundedIndex, 0, count - 1);\n      setCurrent(targetIndex);\n      api.start({\n        position: (loop ? roundedIndex : boundIndex(roundedIndex)) * 100,\n        immediate\n      });\n    }\n    function swipeNext() {\n      swipeTo(Math.round(position.get() / 100) + 1);\n    }\n    function swipePrev() {\n      swipeTo(Math.round(position.get() / 100) - 1);\n    }\n    useImperativeHandle(ref, () => ({\n      swipeTo,\n      swipeNext,\n      swipePrev\n    }));\n    useIsomorphicLayoutEffect(() => {\n      const maxIndex = validChildren.length - 1;\n      if (current > maxIndex) {\n        swipeTo(maxIndex, true);\n      }\n    });\n    const {\n      autoplay,\n      autoplayInterval\n    } = props;\n    useEffect(() => {\n      if (!autoplay || dragging) return;\n      const interval = window.setInterval(() => {\n        swipeNext();\n      }, autoplayInterval);\n      return () => {\n        window.clearInterval(interval);\n      };\n    }, [autoplay, autoplayInterval, dragging, count]);\n    function renderTrackInner() {\n      if (loop) {\n        return React.createElement(\"div\", {\n          className: `${classPrefix}-track-inner`\n        }, React.Children.map(validChildren, (child, index) => {\n          return React.createElement(animated.div, {\n            className: `${classPrefix}-slide`,\n            style: {\n              [isVertical ? 'y' : 'x']: position.to(position => {\n                let finalPosition = -position + index * 100;\n                const totalWidth = count * 100;\n                const flagWidth = totalWidth / 2;\n                finalPosition = modulus(finalPosition + flagWidth, totalWidth) - flagWidth;\n                return `${finalPosition}%`;\n              }),\n              [isVertical ? 'top' : 'left']: `-${index * 100}%`\n            }\n          }, child);\n        }));\n      } else {\n        return React.createElement(animated.div, {\n          className: `${classPrefix}-track-inner`,\n          style: {\n            [isVertical ? 'y' : 'x']: position.to(position => `${-position}%`)\n          }\n        }, React.Children.map(validChildren, child => {\n          return React.createElement(\"div\", {\n            className: `${classPrefix}-slide`\n          }, child);\n        }));\n      }\n    }\n    const style = {\n      '--slide-size': `${props.slideSize}%`,\n      '--track-offset': `${props.trackOffset}%`\n    };\n    return withNativeProps(props, React.createElement(\"div\", {\n      className: classNames(classPrefix, `${classPrefix}-${props.direction}`),\n      style: style\n    }, React.createElement(\"div\", Object.assign({\n      ref: trackRef,\n      className: classNames(`${classPrefix}-track`, {\n        [`${classPrefix}-track-allow-touch-move`]: props.allowTouchMove\n      }),\n      onClickCapture: e => {\n        if (draggingRef.current) {\n          e.stopPropagation();\n        }\n        forceCancelDrag();\n      }\n    }, props.allowTouchMove ? bind() : {}), renderTrackInner()), props.indicator === undefined ? React.createElement(\"div\", {\n      className: `${classPrefix}-indicator`\n    }, React.createElement(PageIndicator, Object.assign({}, props.indicatorProps, {\n      total: count,\n      current: current,\n      direction: props.direction\n    }))) : props.indicator(count, current)));\n  };\n}));\nfunction modulus(value, division) {\n  const remainder = value % division;\n  return remainder < 0 ? remainder + division : remainder;\n}","map":{"version":3,"names":["React","forwardRef","useEffect","useImperativeHandle","useMemo","useRef","useState","withNativeProps","mergeProps","classNames","SwiperItem","devWarning","useSpring","animated","useDrag","PageIndicator","staged","useRefState","bound","useIsomorphicLayoutEffect","useUpdateEffect","classPrefix","defaultProps","defaultIndex","allowTouchMove","autoplay","autoplayInterval","loop","direction","slideSize","trackOffset","stuckAtBoundary","rubberband","currentUid","Swiper","p","ref","props","uid","isVertical","slideRatio","offsetRatio","validChildren","count","Children","map","children","child","isValidElement","type","trackRef","getSlidePixels","track","current","trackPixels","offsetHeight","offsetWidth","setCurrent","_a","onIndexChange","call","dragging","setDragging","draggingRef","boundIndex","min","max","position","api","config","tension","friction","onRest","rawX","get","totalWidth","standardPosition","modulus","start","immediate","dragCancelRef","forceCancelDrag","bind","state","cancel","intentional","first","last","undefined","slidePixels","paramIndex","offset","velocity","minIndex","Math","floor","maxIndex","index","round","swipeTo","window","setTimeout","transform","x","y","from","triggerAllEvents","bounds","lowerBound","upperBound","top","bottom","left","right","axis","preventScroll","pointer","touch","roundedIndex","targetIndex","swipeNext","swipePrev","length","interval","setInterval","clearInterval","renderTrackInner","createElement","className","div","style","to","finalPosition","flagWidth","Object","assign","onClickCapture","e","stopPropagation","indicator","indicatorProps","total","value","division","remainder"],"sources":["/Users/xinyonghu/Desktop/personalCode/react18-learn/xiaotaimei/node_modules/antd-mobile/es/components/swiper/swiper.js"],"sourcesContent":["import React, { forwardRef, useEffect, useImperativeHandle, useMemo, useRef, useState } from 'react';\nimport { withNativeProps } from '../../utils/native-props';\nimport { mergeProps } from '../../utils/with-default-props';\nimport classNames from 'classnames';\nimport { SwiperItem } from './swiper-item';\nimport { devWarning } from '../../utils/dev-log';\nimport { useSpring, animated } from '@react-spring/web';\nimport { useDrag } from '@use-gesture/react';\nimport PageIndicator from '../page-indicator';\nimport { staged } from 'staged-components';\nimport { useRefState } from '../../utils/use-ref-state';\nimport { bound } from '../../utils/bound';\nimport { useIsomorphicLayoutEffect, useUpdateEffect } from 'ahooks';\nconst classPrefix = `adm-swiper`;\nconst defaultProps = {\n  defaultIndex: 0,\n  allowTouchMove: true,\n  autoplay: false,\n  autoplayInterval: 3000,\n  loop: false,\n  direction: 'horizontal',\n  slideSize: 100,\n  trackOffset: 0,\n  stuckAtBoundary: true,\n  rubberband: true\n};\nlet currentUid;\nexport const Swiper = forwardRef(staged((p, ref) => {\n  const props = mergeProps(defaultProps, p);\n  const [uid] = useState({});\n  const isVertical = props.direction === 'vertical';\n  const slideRatio = props.slideSize / 100;\n  const offsetRatio = props.trackOffset / 100;\n  const {\n    validChildren,\n    count\n  } = useMemo(() => {\n    let count = 0;\n    const validChildren = React.Children.map(props.children, child => {\n      if (!React.isValidElement(child)) return null;\n      if (child.type !== SwiperItem) {\n        devWarning('Swiper', 'The children of `Swiper` must be `Swiper.Item` components.');\n        return null;\n      }\n      count++;\n      return child;\n    });\n    return {\n      validChildren,\n      count\n    };\n  }, [props.children]);\n  if (count === 0 || !validChildren) {\n    devWarning('Swiper', '`Swiper` needs at least one child.');\n    return null;\n  }\n  return () => {\n    let loop = props.loop;\n    if (slideRatio * (count - 1) < 1) {\n      loop = false;\n    }\n    const trackRef = useRef(null);\n    function getSlidePixels() {\n      const track = trackRef.current;\n      if (!track) return 0;\n      const trackPixels = isVertical ? track.offsetHeight : track.offsetWidth;\n      return trackPixels * props.slideSize / 100;\n    }\n    const [current, setCurrent] = useState(props.defaultIndex);\n    useUpdateEffect(() => {\n      var _a;\n      (_a = props.onIndexChange) === null || _a === void 0 ? void 0 : _a.call(props, current);\n    }, [current]);\n    const [dragging, setDragging, draggingRef] = useRefState(false);\n    function boundIndex(current) {\n      let min = 0;\n      let max = count - 1;\n      if (props.stuckAtBoundary) {\n        min += offsetRatio / slideRatio;\n        max -= (1 - slideRatio - offsetRatio) / slideRatio;\n      }\n      return bound(current, min, max);\n    }\n    const [{\n      position\n    }, api] = useSpring(() => ({\n      position: boundIndex(current) * 100,\n      config: {\n        tension: 200,\n        friction: 30\n      },\n      onRest: () => {\n        if (draggingRef.current) return;\n        if (!loop) return;\n        const rawX = position.get();\n        const totalWidth = 100 * count;\n        const standardPosition = modulus(rawX, totalWidth);\n        if (standardPosition === rawX) return;\n        api.start({\n          position: standardPosition,\n          immediate: true\n        });\n      }\n    }), [count]);\n    const dragCancelRef = useRef(null);\n    function forceCancelDrag() {\n      var _a;\n      (_a = dragCancelRef.current) === null || _a === void 0 ? void 0 : _a.call(dragCancelRef);\n      draggingRef.current = false;\n    }\n    const bind = useDrag(state => {\n      dragCancelRef.current = state.cancel;\n      if (!state.intentional) return;\n      if (state.first && !currentUid) {\n        currentUid = uid;\n      }\n      if (currentUid !== uid) return;\n      currentUid = state.last ? undefined : uid;\n      const slidePixels = getSlidePixels();\n      if (!slidePixels) return;\n      const paramIndex = isVertical ? 1 : 0;\n      const offset = state.offset[paramIndex];\n      const direction = state.direction[paramIndex];\n      const velocity = state.velocity[paramIndex];\n      setDragging(true);\n      if (!state.last) {\n        api.start({\n          position: offset * 100 / slidePixels,\n          immediate: true\n        });\n      } else {\n        const minIndex = Math.floor(offset / slidePixels);\n        const maxIndex = minIndex + 1;\n        const index = Math.round((offset + velocity * 2000 * direction) / slidePixels);\n        swipeTo(bound(index, minIndex, maxIndex));\n        window.setTimeout(() => {\n          setDragging(false);\n        });\n      }\n    }, {\n      transform: ([x, y]) => [-x, -y],\n      from: () => {\n        const slidePixels = getSlidePixels();\n        return [position.get() / 100 * slidePixels, position.get() / 100 * slidePixels];\n      },\n      triggerAllEvents: true,\n      bounds: () => {\n        if (loop) return {};\n        const slidePixels = getSlidePixels();\n        const lowerBound = boundIndex(0) * slidePixels;\n        const upperBound = boundIndex(count - 1) * slidePixels;\n        return isVertical ? {\n          top: lowerBound,\n          bottom: upperBound\n        } : {\n          left: lowerBound,\n          right: upperBound\n        };\n      },\n      rubberband: props.rubberband,\n      axis: isVertical ? 'y' : 'x',\n      preventScroll: !isVertical,\n      pointer: {\n        touch: true\n      }\n    });\n    function swipeTo(index, immediate = false) {\n      const roundedIndex = Math.round(index);\n      const targetIndex = loop ? modulus(roundedIndex, count) : bound(roundedIndex, 0, count - 1);\n      setCurrent(targetIndex);\n      api.start({\n        position: (loop ? roundedIndex : boundIndex(roundedIndex)) * 100,\n        immediate\n      });\n    }\n    function swipeNext() {\n      swipeTo(Math.round(position.get() / 100) + 1);\n    }\n    function swipePrev() {\n      swipeTo(Math.round(position.get() / 100) - 1);\n    }\n    useImperativeHandle(ref, () => ({\n      swipeTo,\n      swipeNext,\n      swipePrev\n    }));\n    useIsomorphicLayoutEffect(() => {\n      const maxIndex = validChildren.length - 1;\n      if (current > maxIndex) {\n        swipeTo(maxIndex, true);\n      }\n    });\n    const {\n      autoplay,\n      autoplayInterval\n    } = props;\n    useEffect(() => {\n      if (!autoplay || dragging) return;\n      const interval = window.setInterval(() => {\n        swipeNext();\n      }, autoplayInterval);\n      return () => {\n        window.clearInterval(interval);\n      };\n    }, [autoplay, autoplayInterval, dragging, count]);\n    function renderTrackInner() {\n      if (loop) {\n        return React.createElement(\"div\", {\n          className: `${classPrefix}-track-inner`\n        }, React.Children.map(validChildren, (child, index) => {\n          return React.createElement(animated.div, {\n            className: `${classPrefix}-slide`,\n            style: {\n              [isVertical ? 'y' : 'x']: position.to(position => {\n                let finalPosition = -position + index * 100;\n                const totalWidth = count * 100;\n                const flagWidth = totalWidth / 2;\n                finalPosition = modulus(finalPosition + flagWidth, totalWidth) - flagWidth;\n                return `${finalPosition}%`;\n              }),\n              [isVertical ? 'top' : 'left']: `-${index * 100}%`\n            }\n          }, child);\n        }));\n      } else {\n        return React.createElement(animated.div, {\n          className: `${classPrefix}-track-inner`,\n          style: {\n            [isVertical ? 'y' : 'x']: position.to(position => `${-position}%`)\n          }\n        }, React.Children.map(validChildren, child => {\n          return React.createElement(\"div\", {\n            className: `${classPrefix}-slide`\n          }, child);\n        }));\n      }\n    }\n    const style = {\n      '--slide-size': `${props.slideSize}%`,\n      '--track-offset': `${props.trackOffset}%`\n    };\n    return withNativeProps(props, React.createElement(\"div\", {\n      className: classNames(classPrefix, `${classPrefix}-${props.direction}`),\n      style: style\n    }, React.createElement(\"div\", Object.assign({\n      ref: trackRef,\n      className: classNames(`${classPrefix}-track`, {\n        [`${classPrefix}-track-allow-touch-move`]: props.allowTouchMove\n      }),\n      onClickCapture: e => {\n        if (draggingRef.current) {\n          e.stopPropagation();\n        }\n        forceCancelDrag();\n      }\n    }, props.allowTouchMove ? bind() : {}), renderTrackInner()), props.indicator === undefined ? React.createElement(\"div\", {\n      className: `${classPrefix}-indicator`\n    }, React.createElement(PageIndicator, Object.assign({}, props.indicatorProps, {\n      total: count,\n      current: current,\n      direction: props.direction\n    }))) : props.indicator(count, current)));\n  };\n}));\nfunction modulus(value, division) {\n  const remainder = value % division;\n  return remainder < 0 ? remainder + division : remainder;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}